% Functional Programming  
  --- Introduction ---
% Prof. Dr. Oliver Braun
% SS 2014

## What is functional programming?

-   high-level view of programming

-   offers a variety of features

-   to build elegant yet powerful libraries of functions

    ~~~~
    addDouble x y = 2*(x+y)
    ~~~~

----

### the model of functional programming

is simple, e.g.,

~~~~
3 + addDouble 4 5
➣ 3 + 2 * (4+5)
➣ 3 + 2 * 9
➣ 3 + 18
➣ 21
~~~~

## What is a function?

-   a **function** is a box with some inputs and an output

-   the output value depends **only** on the input values

-   output = result \
    inputs = arguments or parameters


-   giving particular inputs to a function is called
    **function application**

-   example: (12 + 34) represents (infix)
    application of the function + to 12 and 34

## Types

-   a functions takes inputs of a particular kind, e.g., numbers

-   and produces a result of a particular kind

-   a collection of values of the same sort is called a **type**, e.g., all numbers

-   example: (+) takes to values of type Integer and produces an Integer

----

###   In modelling:

-   types represent the *things* in the domain

-   types often correspond to *nouns*

-   functions, which transform or combine values from these types, are like *verbs*

## Why Haskell?

-   build secure, error-free, systems used by thousands of people, e.g.,

    -   Unix Window Manager [Xmonad](http://xmonad.org/)

    -   [Cryptol](http://www.cryptol.net/)

-   ideal for DSLs

-   laboratory for new ideas presented in the clearest possible way

-   help you think about programming in a different way

----

### perfect knowledge for

-   using *mainstream* functional languages afterwards

    -   F# on .NET

    -   Scala, Clojure on the JVM

    -   Erlang

-   or functional features in mainstream languages

## The Haskell programming language

-   first defined 1990

-   current version: Haskell 2010

-   named after Haskell B. Curry, a λ calculus pioneer

-   various links on <http://ob.cs.hm.edu/lectures/fun>

-   we use the [FP Haskell Center](https://www.fpcomplete.com/business/fp-haskell-center/) \
    ➣ you have to create an account by yourself

-   you can also use GHC/GHCi, which is part of the [Haskell Platform](http://haskell.org/platform),
    on your own computer

-   and I can provide you a login on a FreeBSD server

## Expressions and evaluation

-   **expression**:

    ~~~~
    (7 - 3) * 2
    ~~~~

-   **evaluation**:

    ~~~~
      (7 - 3) * 2
    ➣ 4      * 2
    ➣ 8
    ~~~~

-   **value**:

    ~~~~
    8
    ~~~~

-   that's exactly what we do in functional programming

    -   defining functions and other values

    -   compute by evaluating expressions

## Definitions

-   a Haskell **programm** consists of a number of definitions

-   a Haskell **definition** associates a **name** (**identifier**) with a value of a particular **type**

-   simplest case

    ~~~~ {.haskell}
    name :: type
    name = expression
    ~~~~

    as in

    ~~~~ {.haskell}
    size :: Integer
    size = 12 + 13
    ~~~~

    -   :: means *is a/is an*, e.g., size is an Integer

    -   value names begin with a **small letter**

    -   type names begin with a **capital letter**

## Function definitions

-   example:

    ~~~~ {.haskell}
    square :: Integer -> Integer
    square n = n*n
    ~~~~

-   first line can be read as

    *square is a function taking an Integer to an Integer*

-   second line means

    *when square is applied to an unknown or variable n, the result is* `n * n`

-   examples with concrete parameters

    ~~~~ {.haskell}
    square 5 = 5 * 5
    ~~~~

    and

    ~~~~ {.haskell}
    square (2+3) = (2+3) * (2+3)
    ~~~~

    lazy evaluation!

## General form

-   function definition

    ~~~~ {.haskell}
    name x1 x2 ... xk = e
    ~~~~

    with

    -   name: `name`

    -   formal parameters: `x1, x2, ..., xk`

    -   result: `e`

-   type signature

    ~~~~ {.haskell}
    name :: t1 -> t2 -> ... -> tk -> t
    ~~~~

    with

    ~~~~ {.haskell}
    x1 :: t1
    x2 :: t2
    ...
    xk :: tk
    e  :: t
    ~~~~

## The essence of Haskell programming

-   in Haskell we use a rich collection of data types to **model** the objects

-   programming is done by writing functions

-   computing with these functions is done by calculation (evaluation) to calculate a result

## Haskell variables vs. variables in imperative languages

-   Haskell variables are like mathematical variables

-   in languages like Java a variable is like a box

-   Haskell has **no state**

-   Haskells functions **don't have side-effects**

## Haskells advantages

-   Haskell programms are *higher-level*: "what, not how"

-   functions can be passed around like *data*

-   functions are without side-effects

    -   I/O, ... is done using **monads**

-   Haskell programms are easy to *parallelize*, because there is no (shared) state

-   equations define properties. therefore, it's easier to write *proofs*

-   without side-effects it's easier to refactor our programms to have a different/better design

## Domain-specific languages

-   Haskell is a general purpose language

-   DSLs are languages used for solving problems in a specific domain

-   examples:

    -   LaTeX, a language for type setting

    -   GraphViz, for graph layout

-   why **embedded DSLs** in Haskell

    -   rich set of data types, including functions and self-defined data types

    -   absence of side-effects

    -   polymorphism, type classes, monads

## ...and what's up next?

#### in the lectures

-   a lot of live coding, using [FP Haskell Center](https://www.fpcomplete.com/ide) and [GHC/GHCi](http://www.haskell.org/platform/)

-   working through [Learn you a haskell for great good!](http://learnyouahaskell.com/chapters) and
    [Parallel and Concurrent Programming in Haskell](http://chimera.labs.oreilly.com/books/1230000000929/index.html)

-   plus testing and some advanced topics

#### in the lab

-   practicing Haskell

-   using the [Yesod Web Framework](http://www.yesodweb.com/)

#### for the "benotete Studienarbeit"

-   implementing a web application in Yesod in small groups (1-3 students)

<!-- vim:spell spelllang=en: -->
