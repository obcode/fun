% Functional Programming  
  --- Generalization: patterns of computation ---
% Prof. Dr. Oliver Braun
% SS 2013

## Example patterns

> transform every element of a list in some way

> combine the elements of a list using some operator

we need functions that take functions as parameters ⇒ **higher-order functions**

## Patterns of computation over lists

-	applying to all: mapping

	~~~~ {.haskell}
	doubleAll [1,2,3] == [2,4,6]
	~~~~

-	selecting elements: filtering

	~~~~ {.haskell}
	digits "29 February 2004" == "292004"
	~~~~

-	combining items: folding

	~~~~ {.haskell}
	sum [1,2,3] == 1+2+3
	~~~~

-	breaking up lists

	~~~~ {.haskell}
	getWord "cat dog" = "cat"
	~~~~

-	combinations

# Higher-order functions: functions as arguments

## Mapping --- the `map` function

~~~~ {.haskell}
map :: (a -> b) -> [a] -> [b]
map f []     = []
map f (x:xs) = f x : map f xs
~~~~

~~~~ {.haskell}
doubleAll = map (2*)
~~~~

~~~~ {.haskell}
convertChrs :: [Char] -> [Int]
convertChrs = map fromEnum
~~~~

## Filtering --- the `filter` function

~~~~ {.haskell}
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
	| p x 		= x : filter p xs
	| otherwise =     filter p xs
~~~~

~~~~ {.haskell}
digits = filter isDigit
~~~~

## Combining `zip` and `map` --- the `zipWith` function

~~~~ {.haskell}
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
zipWith _ _      _      = []
~~~~

~~~~ {.haskell}
addElements = zipWith (+)
~~~~

# Folding and primitive recursion

## `foldr1`

~~~~ {.haskell}
foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 f [x]    = x
foldr1 f (x:xs) = f x (foldr1 f xs)
~~~~

~~~~ {.haskell}
foldr1 (+) [1,2,3] == 1+2+3
~~~~

## `foldr`

~~~~ {.haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ s []     = s
foldr f s (x:xs) = f x (foldr f s xs)
~~~~

~~~~ {.haskell}
concat = foldr (++) []
~~~~

~~~~ {.haskell}
isSort :: [Integer] -> [Integer]
isSort = foldr ins []

ins x []    = [x]
ins x (y:ys)
  | x <= y      = x : y : ys
  | otherwise   = y : ins x ys
~~~~

<!-- vim:spell spelllang=en: -->
