% Functional Programming  
 Â --- Algebraic types ---
% Prof. Dr. Oliver Braun
% SS 2013

## Recursive algebraic types --- expressions

-   data type

    ~~~~ {.haskell}
    data Expr = Lit Integer
              | Add Expr Expr
              | Sub Expr Expr
    ~~~~

-   some examples

    ~~~~ {.haskell}
    Lit 2
    Add (Lit 2) (Lit 3)
    Add (Sub (Lit 3) (Lit 1)) (Lit 3)
    ~~~~

-   an evaluation function

    ~~~~ {.haskell}
    eval :: Expr -> Integer
    eval (Lit n)     = n
    eval (Add e1 e2) = (eval e1) + (Eval e2)
    eval (Sub e1 e2) = (eval e1) - (Eval e2)
    ~~~~

## Using infix constructors

-   a little bit nicer

    ~~~~ {.haskell}
    data Expr = Lit Integer
              | Expr :+: Expr
              | Expr :-: Expr
    ~~~~

-   first character of infix constructor has to be a `:`

## Recursive algebraic types --- trees of integers

-   data type

    ~~~~ {.haskell}
    data NTree = NilT
               | Node Integer NTree NTree
    ~~~~

-   some examples

    ~~~~ {.haskell}
    Node 10 NilT NilT
    Node 17 (Node 14 NilT NilT) (Node 20 NilT NilT)
    ~~~~

-   some functions

    ~~~~ {.haskell}
    sumTree :: NTree -> Integer
    sumTree NilT           = 0
    sumTree (Node n t1 t2) = n + sumTree n1 + sumTree n2

    depth :: NTree -> Integer
    depth NilT           = 0
    depth (Node _ t1 t2) = 1 + max (depth t1) (depth t2)
    ~~~~

## Mutual Recursion

~~~~ {.haskell}
data Person = Adult Name Adress Bio
            | Child Name
data Bio    = Parent String [Person]
            | NonParent String
~~~~

## Polymorphic algebraic types

-   a simple example type

    ~~~~ {.haskell}
    data Pairs a = Pr a a
    ~~~~

-   some example values

    ~~~~ {.haskell}
    Pr 2 3    :: Pairs Integer
    Pr [] [3] :: Pairs [Integer]
    Pr [] []  :: Pairs [a]
    ~~~~

-   a function

    ~~~~ {.haskell}
    equalPair :: Eq a => Pairs a => Bool
    equalPair (Pr x y) = x==y
    ~~~~

## Lists and binary trees

-   lists

    ~~~~ {.haskell}
    infixr 5 :::

    data List a = NilL | a ::: (List a)
        deriving (Eq,Ord,Show,Read)
    ~~~~

-   binary trees

    ~~~~ {.haskell}
    data Tree a = Nil | Node a (Tree a) (Tree a)
        deriving (Eq,Ord,Show,Read)
    ~~~~

## The union type, `Either`

-   the union or sum type

    ~~~~ {.haskell}
    data Either a b = Left a | Right b
        deriving (Eq,Ord,Show,Read)
    ~~~~

-   example values

    ~~~~ {.haskell}
    Left "Duke of Prunes" :: Either String b
    Right 33312           :: Either a Integer
    ~~~~

-   example functions

    ~~~~ {.haskell}
    isLeft :: Either a b -> Bool
    isLeft (Left _)  = True
    isLeft (Right _) = False

    fun :: Either a b -> Integer
    fun (Left x)  = ...x...
    fun (Right y) = ...y...

    either :: (a -> c) -> (b -> c) -> Either a b -> c
    either f _ (Left x)  = f x
    either _ g (Right y) = g y
    ~~~~

## Modelling program errors

-   using the `error` function

    ~~~~ {.haskell}
    error :: String -> a
    ~~~~

    results in an exception, e.g.,

    ~~~~ {.haskell}
    divide :: Integer -> Integer -> Integer
    divide _ 0 = error "divide by zero"
    divide n m = n `div` m
    ~~~~

-   or using the `Maybe` type

    ~~~~ {.haskell}
    data Maybe a = Nothing | Just a
        deriving (Eq,Ord,Show,Read)
    ~~~~

    has a "packed" result type, e.g.,

    ~~~~ {.haskell}
    divide :: Integer -> Integer -> Maybe Integer
    divide _ 0 = Nothing
    divide n m = Just $ n `div` m
    ~~~~

-   a nice helper function for "unpacking"

    ~~~~ {.haskell}
    maybe :: b -> (a -> b) -> Maybe a -> b
    maybe n _ Nothing  = n
    maybe _ f (Just x) = f x
    ~~~~

<!-- vim:spell spelllang=en: -->
