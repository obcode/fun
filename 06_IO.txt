% Functional Programming  
 Â --- IO in Haskell ---
% Prof. Dr. Oliver Braun
% SS 2013

## Why is I/O an issue?

-   a functional program consists of definitions, e.g.,

    ~~~~ {.haskell}
    val :: Integer
    val = 42

    function :: Integer -> Integer
    function n = val + n
    ~~~~

-   using a function like

    ~~~~ {.haskell}
    inputInt :: Integer
    ~~~~

    for reading in an integer from input breaks Haskells model!

## The basics of input/output

-   Haskell provides a type `IO a` of **I/O actions** of type `a`

-   reading input

    ~~~~ {.haskell}
    getLine :: IO String
    getChar :: IO Char
    ~~~~

-   one-element type unit

    ~~~~ {.haskell}
    IO ()
    ~~~~

-   `Main` module and `main` program

    ~~~~ {.haskell}
    main :: IO ()
    ~~~~

## Writing ...

-   Strings

    ~~~~ {.haskell}
    putStr :: String -> IO ()

    putStrLn :: String -> IO ()
    putStrLn = putStr . (++"\n")
    ~~~~

-   values in general

    ~~~~ {.haskell}
    show :: Show a => a -> String

    print :: Show a => a -> IO ()
    print = putStrLn . show
    ~~~~

## Returning a value

-   an I/O action which does no I/O but returns a value

    ~~~~ {.haskell}
    return :: a -> IO a
    ~~~~

-   example

    ~~~~ {.haskell}
    if condition
        then doIoAction
        else return ()
    ~~~~

## The `do` notation

-   sequence I/O programms

-   name (bind) the values returned by I/O actions

## Examples

~~~~ {.haskell}
putStrLn :: String -> IO ()
putStrLn str = do
    putStr str
    putStr "\n"
~~~~

~~~~ {.haskell}
put4times :: String -> IO ()
put4times str = do
    putStrLn str
    putStrLn str
    putStrLn str
    putStrLn str
~~~~

~~~~ {.haskell}
read2lines :: IO ()
read2lines = do
    getLine
    getLine
    putStrLn "Two lines read."
~~~~

## Capturing the values read

~~~~ {.haskell}
getNInput :: IO ()
getNInput = do
    line <- getLine
    putStrLn line
~~~~

~~~~ {.haskell}
reverse2lines :: IO ()
reverse2lines = do
    line1 <- getLine
    line2 <- getLine
    putStrLn (reverse line2)
    putStrLn (reverse line1)
~~~~

## Local definitions in a `do` expression

~~~~ {.haskell}
reverse2lines :: IO ()
reverse2lines = do
    line1 <- getLine
    line2 <- getLine
    let rev1 = reverse line1
    let rev2 = reverse line2
    putStrLn rev2
    putStrLn rev1
~~~~

## Reading values in general

~~~~ {.haskell}
read :: Read a => String -> a
~~~~

~~~~ {.haskell}
getInt :: IO Integer
getInt = do
    line <- getLine
    return (read line :: Integer)
~~~~

see `readLn`

## Loops and recursion

~~~~ {.haskell}
echo :: IO ()
echo = do
    line <- getLine
    putStrLn line
    echo
~~~~

~~~~ {.haskell}
echoN :: Integer -> IO ()
echoN n =
    if n <= 0
    then return ()
    else do
        line <- getLine
        putStrLn line
        echoN (n-1)
~~~~

~~~~ {.haskell}
echoEmpty :: IO ()
echoEmpty = do
    line <- getLine
    if null line
        then return ()
        else do
            putStrLn line
            echoEmpty
~~~~

~~~~ {.haskell}
echoCount :: IO ()
echoCount = echoCount' 0

echoCount' :: Integer -> IO ()
echoCount' n = do
    line <- getLine
    if null line
        then putStrLn (show n ++ " lines echoed.")
        else do
            putStrLn line
            echoCount' (n+1)
~~~~

<!-- vim:spell spelllang=en: -->
