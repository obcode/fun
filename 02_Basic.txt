% Functional Programming  
  --- Basic types and definitions ---
% Prof. Dr. Oliver Braun
% SS 2013

## The Booleans: `Bool`

-   values: `True` and `False` of type [`Bool`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Bool.html)

-   boolean operators

    -   `&&`

    -   `||`

    -   `not`

-   equality and inequality

    -   `==`

    -   `/=`

-   defining xOr

    ~~~~ {.haskell}
    exOr :: Bool -> Bool -> Bool
    exOr x y = (x || y) && not (x && y)
    ~~~~

## Literals and definitions

-   we can define our own not:

    ~~~~ {.haskell}
    myNot :: Bool -> Bool
    myNot True  = False
    myNot False = True
    ~~~~

-   we can combine literals and variables

    ~~~~ {.haskell}
    exOr True  x = not x
    exOr False x = x
    ~~~~

-   using `True` and `False` on the left-hand side is called **pattern matching**

## Testing

-   QuickCheck properties

    ~~~~ {.haskell}
    prop_myNot :: Bool -> Bool
    prop_myNot x = not x == myNot x

    ...
    ~~~~

## The integers: `Integer` and `Int`

-   [`Integer`](http://www.haskell.org/ghc/docs/latest/html/libraries/integer-gmp-0.5.0.0/GHC-Integer-GMP-Internals.html) can be arbitrary large

-   operations and functions

    ~~~~ {.haskell}
    +
    *
    ^
    -
    div
    mod
    abs
    negate
    ~~~~

## Relational operators

-   operators

    ~~~~ {.haskell}
    >
    >=
    ==
    /=
    <=
    <
    ~~~~

-   example

    ~~~~ {.haskell}
    threeEqual :: Integer -> Integer -> Integer -> Bool
    threeEqual m n p = (m==n) && (n==p)
    ~~~~

## Negative literals

-   problem

    ~~~~
    Prelude> abs -34

    <interactive>:5:5:
        No instance for (Num (a0 -> a0))
          arising from a use of `-'
        Possible fix: add an instance declaration for (Num (a0 -> a0))
        In the expression: abs - 34
        In an equation for `it': it = abs - 34
    ~~~~

-   solution

    ~~~~
    Prelude> abs (-34)
    34
    ~~~~

## Fixed-size integers: `Int`

-   type [`Int`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Int.html) with bounds

    ~~~~
    Prelude> maxBound :: Int
    9223372036854775807
    Prelude> minBound :: Int
    -9223372036854775808
    ~~~~

    $\Rightarrow$ 64 bit integers on my 64 bit machine

-   more efficient than `Integer`

-   all `Integer`-functions are available in an overloaded version for `Int`

-   conversion between both

    ~~~~ {.haskell}
    fromInteger :: Integer -> Int
    toInteger   :: Int -> Integer
    ~~~~

## Overloading

-   the equality operator `==` can be used for different types

-   this means it has different types

    ~~~~ {.haskell}
    Int -> Int -> Bool
    Integer -> Integer -> Bool
    Bool -> Bool -> Bool
    ~~~~

-   the most general type is

    ~~~~ {.haskell}
    (==) :: Eq a => a -> a -> Bool
    ~~~~

-   `Eq` can be viewed as a set containing all types for which the equality operator has been defined

-   `Eq a` can be read as $\forall a \in Eq$

-   the type does not allow us to compare elements of different type

## Guards

-   example

    ~~~~ {.haskell}
    max :: Integer -> Integer -> Integer
    max x y
        | x >= y    = x
        | otherwise = y
    ~~~~

-   if the first guard (`x>=y`) is `True` the value is `x`

-   more guards

    ~~~~ {.haskell}
    maxThree :: Integer -> Integer -> Integer -> Integer
    maxThree x y z
        | x >= y && x >= z    = x
        | y >= z              = y
        | otherwise           = z
    ~~~~

-   `otherwise` is not compulsory

## Redefining prelude functions

-   `max` is already defined in the prelude:

    ~~~~
    Ambiguous occurrence `max'
    It could refer to either `MyModule.max', defined at ...
                          or `Prelude.max',
                             imported from `Prelude' at ...
    ~~~~

-   it's possible to redefine the functions when hiding them

    ~~~~ {.haskell}
    import Prelude hiding (max)
    ~~~~

## Conditional expressions

-   `if ... then ... else`

    ~~~~ {.haskell}
    max' x y = if x >= y then x else y
    ~~~~

-   heads-up: there is **no** `if` without `else`

-   it's like `?:` in C

## Characters

-   unicode characters have type [`Char`](http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Data-Char.html)

-   conversion from and to `Int`

    ~~~~ {.haskell}
    fromEnum :: Char -> Int
    toEnum   :: Int -> Char
    ~~~~

    representing the unicode value

-   example usage

    ~~~~ {.haskell}
    offset :: Int
    offset = fromEnum 'A' - fromEnum 'a'

    toUpper :: Char -> Char
    toUpper cs = toEnum (fromEnum ch + offset)
    ~~~~

-   characters can be compared, example:

    ~~~~ {.haskell}
    isDigit :: Char -> Bool
    isDigit ch = ('0' <= ch) && (ch <= '9')
    ~~~~

## Strings

-   literals as usual:

    ~~~~ {.haskell}
    "Hello, world!\n"
    ~~~~

-   strings can be joined together using `++`

    ~~~~ {.haskell}
    "Hello"++", "++"world"++"!"
    ~~~~

-   strings can be printed out using the function

    ~~~~ {.haskell}
    putStr :: String -> IO ()
    ~~~~

## Strings and values

-   there are two overloaded functions `show` and `read` for converting a value to a string and vice versa

-   examples:

    ~~~~ {.haskell}
    show (2+3)           -- "5"
    show (True || False) -- "True"

    read "True"          -- True
    read "3"             -- 3
    ~~~~

-   heads-up:

    ~~~~
    Prelude> read "3"

    <interactive>:11:1:
        Ambiguous type variable `a0' in the constraint:
          (Read a0) arising from a use of `read'
        Probable fix: add a type signature that fixes these type variable(s)
        In the expression: read "3"
        In an equation for `it': it = read "3" 
    ~~~~

-   fix:

    ~~~~ {.haskell}
    Prelude> (read "3") :: Int
    3
    ~~~~

## Floating-point numbers: `Float` and `Double`

-   single-precision and double-precision floating point numbers

-   literals

    ~~~~ {.haskell}
    0.31426
    -23.12
    567.347
    4523.0
    ~~~~

-   scientific notation as usual

    ~~~~ {.haskell}
    231.61e-2
    ~~~~

-   standard mathematical operations in prelude

-   converting integers to floating-point numbers: `fromInteger` and `fromIntegral`

-   vice versa: `ceiling`, `floor`, and `round`

## Overloaded literals

-   in Haskell it is possible to use a literal for values of different types:

    ~~~~
    Prelude> 3 :: Int
    3
    Prelude> 3 :: Integer
    3
    Prelude> 3 :: Float
    3.0
    Prelude> 3 :: Double
    3.0
    ~~~~

## Syntax: Definitions and layout

-   offside rule

    ~~~~ {.haskell}
    mystery x = x * x       -- mystery
                            -- mystery
        +x                  -- mystery
                            -- mystery
                +2          -- mystery
                            -- mystery
    next y = ...            -- next
    ~~~~

-   formally: a definition is ended by the first piece of text which lies at the same indentation or to the left of the start of the definition

-   it is possible to use a semicolon if we want to write more than one definition on a single line

    ~~~~ {.haskell}
    answer = 42 ; facSix = 720
    ~~~~

## Recommended layout

-   maximum line length 80 characters

-   do not use tabs

-   indent 4 spaces

-   for more see [Johan Tibell’s style guide](https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md)

## Names in Haskell

-   function and value names must begin with a small letter

-   types and constructors must begin with a capital letter

-   reserved words:

    ~~~~
    case  class  data  default  deriving  do  else
    foreign  if  import  in  infix  infixl
    infixr  instance  let  module  newtype  of
    then  type  where  _
    ~~~~

## Operators

-   operators are infix functions

    ~~~~ {.haskell}
    (((4+8)*3)+2)
    ~~~~

## Associativity

-   some operators are associative, like `+`

    4+8+99 is the same as (4+8)+99 is the same as 4+(8+99)

-   others are not, i.e.,

    (4-2)-1 = 2-1 = 1  (*left-associative*)  
    4-(2-1) = 4-1 = 3  (*right-associative*)

-   for all non-associative operators it is classified if they are left- or right-associative

-   `-` is left-associative:

    4-2-1 is the same as (4-2)-1

## Binding powers

-   what is done in the following expressions?

    ~~~~ {.haskell}
    2+3*4
    3^4*2
    ~~~~

-   **binding power** or **fixity**:

    -   `*` has binding power 7

    -   `+` has binding power 6

    -   `^` has binding power 8

-   this means above expressions are equivalent with

    ~~~~ {.haskell}
    2+(3*4)
    (3^4)*2
    ~~~~

-   heads-up: function application is binding most tightly

    -   `f n+1` is interpreted as `(f n) + 1`

    -   `f -1` is interpreted as `f - 1`

## Operators and functions

-   Infix operators can be written *before* their arguments, by enclosing the operator in parentheses, i.e.,

    ~~~~ {.haskell}
    (+) 2 3
    ~~~~

-   in the type signature of an operator we also have to use parentheses:

    ~~~~ {.haskell}
    (+) :: Integer -> Integer -> Integer
    ~~~~

-   we can also convert functions into operators by enclosing the function name in backquotes:

    ~~~~ {.haskell}
    5 `mod` 2
    ~~~~

## Do-it-yourself operators

-   we can define our own infix operators

-   it is possible to use Unicode symbols and the following ASCII symbols:

    ~~~~ {.haskell}
    !  #  $  %  &  ⋆  +  .  /  <  =  >  ?  @
	\  ^    -  ~  :
    ~~~~

-   example

    ~~~~ {.haskell}
    (&&&) :: Integer -> Integer -> Integer
    x &&& y
        | x > y     = y
        | otherwise = x
    ~~~~
 
<!-- vim:spell spelllang=en: -->
