% Functional Programming  
 Â --- More about Lists ---
% Prof. Dr. Oliver Braun
% SS 2013

## Generic functions: polymorphism

-   length of a list

    ~~~~ {.haskell}
    length :: [Bool] -> Int
    length :: [[Char]] -> Int
    ~~~~

-   generic type of `length` using a type variable

    ~~~~ {.haskell}
    length :: [a] -> Int
    ~~~~

-   there is just one `length` function which can be applied to lists with arbitrary element types

## Prelude: list functions

<http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.1/Prelude.html#g:11>

## More examples

Simon Thompsons examples:

<http://hackage.haskell.org/package/Craft3e-0.1.0.10>

-   `Picture.hs`

-   See Chapter 6

## Defining functions over lists

-   Patten matching examples

    ~~~~ {.haskell}
    head :: [a] -> a
    head (x:_) = x

    null :: [a] -> Bool
    null []    = True
    null (_:_) = False
    ~~~~

## `case` --- Pattern matching on the right hand side

-   form:

    ~~~~ {.haskell}
    case e of
        p1 -> e1
        p2 -> e2
        ...
        pn -> en
    ~~~~

-   example

    ~~~~ {.haskell}
    firstDigit :: String -> Char
    firstDigit str =
        case digits str of
            []    -> '\0'
            (x:_) -> x
    ~~~~

## Primitive recursion over lists

-   example

    ~~~~ {.haskell}
    sum :: [Integer] -> Integer
    sum []     = 0
    sum (x:xs) = x + sum xs
    ~~~~

## General recursion over lists

-   example

    ~~~~ {.haskell}
    zip :: [a] -> [b] -> [(a,b)]
    zip (x:xs) (y:ys) = (x,y) : zip xs ys
    zip _      _      = []
    ~~~~

-   what is the result of

    ~~~~ {.haskell}
    zip [1..] "Hello, world!"
    ~~~~

-   another example

    ~~~~ {.haskell}
    take :: Int -> [a] -> [a]
    take 0 _  = []
    take _ [] = []
    take n (x:xs)
        | n>0 = x : take (n-1) xs
    take _ _  = error "PreludeList.take: negative argument"
    ~~~~

## Quicksort

~~~~ {.haskell}
quickSort :: [Integer] -> [Integer]
quickSort [] = []
quickSort (x:xs) =
       quickSort [ y | y <- xs, y<=x ]
    ++ [x]
    ++ quickSort [ y | y <- xs, y>x ]
~~~~

## Example

Text processing: Chapter7.hs in Craft3e

<!-- vim:spell spelllang=en: -->
